---
layout: default
title: "The Final Touches (4/20)"
---
<h1>The Final Touches</h1>

<h2>The Final Word On Wwise and Version Control</h2>
<p>
    A reoccurring challenge for the studio has been making the Wwise audio system play nice with version control. When it comes to Unity, there are many excellent resources for handling each kind of file, and even a standard gitignore file. Conversely, Wwise and its Unity integration seems to be a small enough of a niche that it can be hard to find good resources for how to handle all of its parts. However, with some final steps of progress made recently, we may have finally conquered this beast. Up to this point, the last remaining common sources of conflicts were in two categories: cache files and work units.
</p>
<p>
    By cache files, I mean files that speed up local operations by caching data, and thus do not need to be included in version control. The tricky part with these is that not all cache files are obvious. At the time, I had my suspicions about three particular files, mainly because they were changed in every audio-related pull request, and they were almost always conflicted. They also appeared to contain absolute files paths, which are obviously specific to a machine. After seeing this come up enough times, it became a high enough priority to warrant investigation. Luckily, I pretty quickly found an article that explained that those should definitely not be included in version control. I also realized that this was not the first time I had seen this article. It had been found by the Audio director early in the semester, but somehow these three files had not made it into the gitignore list. A bit frustrating, but I suppose it was a good lesson in preserving information.
</p>
<p>
    Work unit files specify the hierarchal structure of a Wwise project, and as such are some of the most important files. This means they are also the most common source of actual merge conflicts. Fortunately, they are in XML format, which is quite human-readable, so it is quite possible for a human to manually reconcile conflicting changes. I decided that is would be worthwhile to attempt to tackle this myself. As I am unfamiliar with the structures of Wwise, I also enlisted the help of the audio designers who were involved in the conflict. The clear, visible structure of the XML format allowed me to see what was added by each side of the conflict. Some of the conflicts were quite simple, just single lines requiring the choice of which to keep. On the other hand, the conflicts that appeared more complex at first were usually caused by the addition of new objects, one on each branch, which had some common section within them. The figure below is a simplified demonstration of how two additions that have a matching section can become an apparently-complex conflict.
    <img src="/images/blog/xml_conflict.png"/>
    Solving such conflicts is just a matter of duplicating those matching sections and reassembling each branch's addition. Overall, I achieved two major merge conflict resolutions, and I have some hope that audio designers may be able to learn how to resolve such conflict independently in the future.
</p>

<h2>Various Final Touches</h2>
<p>
    The last 2 weeks of development were mostly just scrambling to polish off each little bug that came up, so here's a sampling of the most challenging / important final touches.
</p>
<p>
    One feature that I added was the ability to skip the animatic cutscenes, which was very important for playtesters, so they didn't have to wait through the cutscenes every time they started a new game. The animatic player system was coded quite cleanly so I was able to easily add a skipping function. To avoid accidental triggering of the skip, it requires the player to hold down one of the skip inputs for a period of time while a UI bar fills up. The major obstacle I faced here came from the input system, where I could encounter some stickiness when pressing multiple skip inputs at once. For example, on a controller, pressing A, pressing start, releasing A, and then releasing start would cause the bar to continue filling, even though no buttons are pressed. I had to mess with the skip input setting to make sure that releasing any skip input would abort regardless of the others being pressed.
</p>
<p>
    To handle the transition from the first game scene to the second, we used a continuous transition, meaning there was no fade to black or loading screen. It would asynchronously load the next scene as the player fell down a pit, and once the player landed, the old scene could be unloaded, as that one cave was present in both scenes. The mechanics of this were successful coded by level design programmers, but I was called in to fix the audio, which would break after this transition. Fixing the audio breaking was simple, but I realized that there were issues with the background of the transition cave, in that the shared back wall did not extend all the way to the bottom, and some background sprites were shown in front of that background. This made the moment of transition, when the scenes switched, very visible, so I modified the background sprite and fixed the sprite sorting order for the second scene to ensure that no visible changes would happen at the moment that the scenes switched.
</p>
<p>
    I believe that global references are, in general, bad practice. I much prefer abstract interactions that can be more easily adapted to new mechanics. I was able to keep the enemies from needing a global reference to the player, instead getting a reference when they are first triggered by the player. I realized more recently, however, that in-game UI more or less <i>needs</i> a global reference to the player. There are other approaches, but the simplest one is really just giving the UI a way to get a player reference and find whatever component they need data from. So I finally caved and added a player reference singleton to provide that.
</p>
<p>
    There was an interesting bug that caused the boss enemy's projectile attacks to completely break. The source was a collision with the Cinemachine(CM) confiner collider. This was a collider that defined bounds for the camera, preventing it from going too far outside the level. Somewhat absurdly, because these colliders do not actually have to collide with anything, their physics layer can be set to not collide with any layer, preventing such an issue. This makes me question why a collider is needed at all. I suppose creating Cinemachine-specific components to define boundaries of various shapes is not valuable when Unity already has colliders, but I can only guess their motivations. In addition to the CM confiner change, the layer for the boss's projectile was changed from the default layer to an "enemy attacks" layer that had more restricted collisions. Each of these changes alone would have fixed the bug, so I consider this a good demonstration that effective game architecture requires multiple mistakes to be made before things start to break.
</p>
<p>
    I mentioned in a previous blog post that Wwise sound banks break when you unload and load the same bank at the same time. I had fixed this for game scenes, but I had to reorganize the banks for the main menu and the cutscenes to make sure they only loaded the sound banks that they needed. Also, strangely enough, someone had added sound banks to some enemy prefabs, so I had to find and remove those.
</p>
<p>
    There was a bug that arose if went back to the main menu from in-game and tried to start a new game. This would give you a white screen, and the skipping function would be broken, so you'd be completely stuck. I found the issue in that the time scale was not set back to normal when exiting to the main menu. The fix was somewhat simple, just making the game manager reset the time scale when loading a new scene. This illustrates a deeper problem in that the time scale of the game was modified in several different places. The player controller modifies it for the slow-motion effects, the pause function modify it, and there's an effect for taking damage that also touches it. With a global variable like the time scale, it's much safer to have a global handler that every other mechanic has to go through, so it can reconcile requests from different sources, rather than each change simply overriding the previous. Implementing this does require planning around the mechanics of the game, and clear communication, both of which are challenges with a large team.
</p>
<p>
    One of the very last touches was a fix to the slow-motion mechanic audio. The audio for the player's slow-motion ability was triggered by two events on the component, for starting and stopping the ability. Upon adding the sounds in, it became very clear that the events were not set properly, as they would be activated every single frame, rather than only at the moments when the ability started or stopped. I fixed this myself, but as I was not the original programmer of that code, and this was a very last-minute change, I had to be very carful to change as little as possible so I would not risk introducing a new bug. Even after I was done, it still sound bad if the player held down the slow-mo input after exhausting their power, as the sound effects would be triggered repeatedly. Fixing that would require a more fundamental reworking of the mechanic, so I had to make the choice to leave it as.
</p>
<p>
    The additions and fixes mentioned above are mainly the things that a personally fixed. There were numerous bugs that I took a more directorial approach to, by investigating only enough to determine the right person to assign, and following up to ensure that they were being fixed. These were certainly more nerve-wracking, as I was never sure exactly when they would be fixed as the deadline approached. Fortunately, the programmers performed well, and every major issue was fixed in time.
</p>